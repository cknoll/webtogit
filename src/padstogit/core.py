import os
import shutil
import requests
import git
import yaml
import pathlib
from typing import List
import appdirs
from ipydex import IPS, activate_ips_on_exception, TracerFactory

ST = TracerFactory()

activate_ips_on_exception()


safty_explanation = """
# The presence (not the content) of this file is checked before the repo is purged.
# This should prevent the software from accidentally deleting an unwanted directory
# e.g. due to mistakes in configuration file.
"""

gitignore_content = f"""

log.txt

{safty_explanation}
.padstogit
"""

APPNAME = "padstogit"


class Core:
    """
    Main class which holds all information
    """

    def __init__(self, testmode=False, **kwargs):

        default_data_path = appdirs.user_data_dir(appname=APPNAME)
        default_config_path = appdirs.user_config_dir(appname=APPNAME)
        self.data_path = (
            kwargs.get("data_path") or os.getenv(f"{APPNAME}_DATAPATH") or default_data_path
        )
        self.config_path = (
            kwargs.get("config_path") or os.getenv(f"{APPNAME}_CONFIGPATH") or default_config_path
        )
        self.sources_path = None
        self.settings = None
        self.repo_dir = None
        self.repo_parent_path = None
        self.repo_name = None
        self.checkfile = None

        self.testmode = testmode

        self._ensure_existing_dicts()
        self.load_settings()

        self.checkfile = os.path.join(self.repo_dir, ".padstogit")

    def _ensure_existing_dicts(self):

        os.makedirs(self.data_path, exist_ok=True)
        os.makedirs(self.config_path, exist_ok=True)

    def load_settings(self):

        os.chdir(self.config_path)

        if self.testmode or os.getenv(f"{APPNAME}_TESTMODE"):
            repo_name = f"{APPNAME}-test-repo"
        else:
            repo_name = "archived-pads"

        self.sources_path = os.path.join(self.data_path, "sources.yml")

        self.settings = {
            "repo_parent_path": self.data_path,
            "repo_name": repo_name,
            "readme_content": "This file was generated by padstogit\n",
        }

        # this simplifies testing
        project_root = pathlib.Path(__file__).parents[2]
        if os.path.isfile(os.path.join(project_root, "setup.py")):
            self.settings["sources"] = os.path.join(project_root, "example-data", "sources.yml")

        self.repo_parent_path = os.path.abspath(self.settings["repo_parent_path"])
        self.repo_name = self.settings["repo_name"]
        self.repo_dir = os.path.join(self.repo_parent_path, self.repo_name)

    def init_pad_repo(self) -> git.Repo:

        os.chdir(self.data_path)

        if os.path.exists(self.repo_dir):
            raise FileExistsError(f"{self.repo_dir} already exists. Please move dir and retry.")

        r = git.Repo.init(self.repo_dir)
        os.chdir(self.repo_dir)

        # prevent the directory from being accidentally deleted
        # this file will be ignored by git due to .gitignore
        fname = self.checkfile
        with open(fname, "w") as txtfile:
            txtfile.write(safty_explanation)

        self.checkfile = os.path.join(self.repo_dir, fname)

        # Create the first files for the repo
        fname = "README.md"
        with open(fname, "w") as txtfile:
            txtfile.write(self.settings["readme_content"])
        r.index.add([fname])

        fname = ".gitignore"
        with open(fname, "w") as txtfile:
            txtfile.write(gitignore_content)
        r.index.add([fname])

        fname = ".padstogit"
        with open(fname, "w") as txtfile:
            txtfile.write(gitignore_content)
        r.index.add([fname])

        r.index.commit("initial commit")

        return r

    def purge_pad_repo(self, ignore_errors=False):

        assert self.checkfile is not None

        if not ignore_errors and not os.path.exists(self.checkfile):
            msg = f"The file `{self.checkfile}` is missing. Abort deletion of `{self.repo_dir}`."
            raise FileNotFoundError(msg)

        shutil.rmtree(self.repo_dir, ignore_errors)

    def load_pad_sources(self) -> list:

        assert os.path.isfile(self.sources_path)

        with open(self.sources_path, "r") as txtfile:
            raw_sources = yaml.safe_load(txtfile)
        assert isinstance(raw_sources, list)

        sources = []
        for s in raw_sources:
            if isinstance(s, str):
                d = {
                    "name": get_padname_from_url(s),
                    "url": s,
                }
                sources.append(d)
            elif isinstance(s, dict):
                assert len(s) == 1
                url, value_obj = list(s.items())[0]

                # assume that there is an inner dict
                assert isinstance(value_obj, dict)
                if not "name" in value_obj:
                    value_obj["name"] = get_padname_from_url(url)
                value_obj["url"] = url

                sources.append(value_obj)
            else:
                raise TypeError(f"unexpexted:{type(s)}")
        return sources

    def goto_paddir(self):
        paddir = os.path.join(self.repo_dir, "pads")
        os.makedirs(paddir, exist_ok=True)
        os.chdir(paddir)

    def download_pad_contents(self):
        """
        create and change to the directory where the pads are actually placed
        (to avoind name collissions)
        """
        sources = self.load_pad_sources()

        self.goto_paddir()

        for sdict in sources:
            fname = sdict["name"]
            url = sdict["url"]

            res = requests.get(url)
            if not res.status_code == 200:
                raise ValueError(f"unexpected status code for url {url}")

            with open(fname, "wb") as txtfile:
                txtfile.write(res.content)

    def get_or_create_repo(self) -> git.Repo:
        try:
            r = git.Repo(self.repo_dir)
        except (git.InvalidGitRepositoryError, git.NoSuchPathError) as err:
            print(f"A git repo does not exist in {self.repo_dir}. Creating a new.")
            r = self.init_pad_repo()

        return r

    def make_commit(self):

        os.chdir(self.repo_dir)
        r = self.get_or_create_repo()

        r.git.add("pads/")
        diff_objects = r.index.diff(r.head.commit)

        changedFiles = [do.a_path for do in diff_objects]

        if changedFiles:

            r.git.commit(message="track changes to pads")

        return changedFiles

    def print_config(self):
        keys = ("config_path", "repo_dir", "sources_path")

        print(f"\n{APPNAME} configuration:")
        for key in keys:
            value = getattr(self, key, None)
            print(f" {key}: {value}")

    @staticmethod
    def make_report(changed_files: List[str]) -> str:
        assert isinstance(changed_files, list)
        report_lines = ["\n", f"{len(changed_files)} files changed:"] + changed_files

        report = "\n".join(report_lines)
        return report

    def main(self, print_flag=True):
        """
        This is the main method of the script. It performs the following steps:

        1. get or create repo
        1. load sources.yml
        2. download files
        3. commit to repo
        4. return and print a report of what as changed
        """

        self.get_or_create_repo()
        sources = self.load_pad_sources()
        self.download_pad_contents()
        changed_files = self.make_commit()

        if print_flag:
            print()
        self.print_config()

        print(self.make_report(changed_files))

        return changed_files


# https://etherpad.wikimedia.org/p/padstogit_testpad1/export/txt


def get_padname_from_url(url, append=".txt"):
    if not url.startswith("http"):
        raise ValueError(f"invalid url: {url}")

    # assume that padnames cannot contain slashes
    padname = url.split("/")[-1]
    return f"{padname}{append}"
